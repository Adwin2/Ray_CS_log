# 设计模式(Golang)

//source: github.com/qingconglaixueit/go_design_pattern

## 创造者模式

- 工厂模式 : 不指定具体类的情况下创建对象默认值
- 抽象工厂模式 ：同上 创建一系列相关的对象
- 生成器模式 ：分步骤创建复杂对象
- 单例模式 ：保证一个类只有一个实例，并提供一个访问该实例的全局节点
- 原型模式 ：复制已有对象，且不依赖所属的类

## 结构型模式

- 适配器模式 ：接口不兼容的对象能够相互合作
- 桥接模式 ：将类拆分为抽象和实现两个层次，分别使用
- 组合模式 ：将对象组合为树状结构，并作为独立对象使用
- 代理模式 ：提供对象的替代品或占位符
- 装饰器模式 ：允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为
- 外观模式 ：能为程序库、 框架或其他复杂类提供一个简单的接口
- 享元模式 ：通过共享多个对象所共有的相同状态

## 行为模式

- 命令模式 ：将请求转换为一个包含与请求相关的所有信息的独立对象
- 策略模式 ：让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换
- 模板模式 ：在超类中定义一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤
- 迭代器模式 ：让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素）
- 观察者模式 ：允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象”
- 责任链模式 ：允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者
- 备忘录模式 ：允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。
- 中介者模式 ：能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。
- 状态模式 ：让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样
- 访问者模式 ：将算法与其所作用的对象隔离开来
